# Project "Market Pulse" - Architectural Principles & Development History


## 1. Guiding Principles for AI-Assisted Development


This document provides a complete technical overview and chronological development history for the Market Pulse application. All future development work must adhere to the following architectural principles to ensure consistency, maintainability, and stability.


### Frontend Architecture: Declarative UI with Alpine.js
- The project has adopted a declarative, state-driven UI model using the Alpine.js library.
- **Rule:** All new UI interactivity must be built within a self-contained Alpine.js component (`x-data`). Manual DOM manipulation (e.g., `document.getElementById`) is to be avoided.
- **Pattern:** The component's state and UI-related methods should be defined within a single object in an external `.mjs` file, which is then imported and registered with Alpine.js in the corresponding HTML file. The HTML file should serve as a clean template, with all logic encapsulated in the JavaScript module.


### Backend Architecture: Modular Express Routers
- The backend has been refactored from a monolithic `server.js` file into a modular architecture.
- **Rule:** All new API endpoints must be added to the appropriate feature-based router file within the `/api/routes/` directory (e.g., `auth.router.js`, `dashboard.router.js`).
- **Pattern:** Shared logic, such as database connections (`db.js`) and authentication middleware (`middleware.js`), should be placed in the `/api/utils/` directory to be reused across routers. The main `server.js` file should remain a lean script responsible only for server initialization and mounting the routers.


### Component Architecture: Reusable Shared Components
- The application utilizes shared UI components to ensure a consistent user experience and reduce code duplication.
- **Rule:** Common UI elements, such as the page header, must be built as reusable components.
- **Pattern:** Shared components should be placed in the `/public/app/_shared/` directory, with their HTML and JavaScript logic separated into `header.html` and `header.mjs` files, respectively. A utility function (`utils.mjs`) is used to load these components dynamically.


### Changelog Maintenance
When requested by the user (Karol), a new entry detailing the completed work must be appended to the end of the "Development History" section. Each new entry must strictly adhere to the existing format used in previous entries (Date, Objective, Key Changes, and Outcome). Previous historical entries are considered immutable and must not be altered. The only section that should be modified is the "Current Project File Structure" tree, which must be updated if any files or directories are added, modified, or deleted.




## 2. Current Project File Structure


market-pulse/
├── api/
│   ├── routes/
│   │   ├── admin.router.js
│   │   ├── auth.router.js
│   │   ├── dashboard.router.js
│   │   └── reports.router.js
│   ├── utils/
│   │   ├── db.js
│   │   └── middleware.js
│   ├── daily-refresh.js
│   ├── initial-sync.js
│   └── send-scheduled-reports.js
├── node_modules/
├── public/
│   ├── admin/
│   │   ├── admin.mjs
│   │   └── index.html
│   ├── app/
│   │   ├── _shared/
│   │   │   ├── header.html
│   │   │   └── header.mjs
│   │   ├── dashboard.mjs
│   │   ├── index.html
│   │   ├── reports.html
│   │   ├── reports.js
│   │   └── utils.mjs
│   ├── constants.mjs
│   └── login.html
├── changelog.md
├── Introduction AI-Assisted Development Workflow.docx
├── package-lock.json
├── package.json
├── server.js
└── vercel.json


## 3. Development History


---


### **Date: July 5, 2025**
- **Objective**: Migrate the project from a local setup to a cloud-native solution and establish the initial dataset.
- **Key Changes**:
    - The application was deployed to Vercel and connected to a production Neon PostgreSQL database.
    - A background data refresh script was converted into a Vercel Serverless Function, scheduled via `vercel.json`.
    - To solve the "cold start" problem, the database was seeded with mock data for five competitor hotels to establish a market for comparison.
    - The backend API was updated to aggregate this mock data, providing an averaged "market" row for the dashboard.
- **Outcome**: The application was successfully deployed to a cloud-native environment with a foundational dataset for market comparisons.


---


### **Date: July 8, 2025**
- **Objective**: Refactor the application into a secure, multi-tenant platform and resolve critical post-deployment issues.
- **Summary**: A major refactoring effort was completed to support multiple hotel clients. This was followed by a debugging session to stabilize the new session management system in a serverless environment.
- **Key Changes**:
    - **Multi-Tenant Refactor (V2.0)**:
        - Implemented the Cloudbeds OAuth 2.0 flow for user onboarding and authentication.
        - Updated the database schema to be user-aware, ensuring data isolation between tenants.
        - Secured all API endpoints using `express-session`.
    - **Post-Deployment Debugging**:
        - **Problem**: Users were unable to log in because the default in-memory session store was not viable in a serverless environment, causing login state to be lost between requests.
        - **Resolution**: Replaced the in-memory store with a persistent PostgreSQL-backed store (`connect-pg-simple`). Implemented previously missing API endpoints (`/api/metrics-from-db`, `/api/competitor-metrics`) to resolve a `TypeError` on the dashboard.
- **Outcome**: The application was successfully converted and stabilized into a fully functional multi-tenant platform.


---


### **Date: July 9, 2025**
- **Objective**: Implement a secure, passwordless magic link login system and resolve a series of critical production bugs.
- **Summary**: This day involved significant work on a new authentication flow, followed by several rounds of high-stakes debugging to restore application stability after encountering build, routing, and caching issues.
- **Key Changes**:
    - **Magic Link Authentication**:
        - A passwordless login system was designed and implemented.
        - Integrated the SendGrid API for sending transactional emails.
        - Added a `magic_login_tokens` table to the database for storing single-use, expiring tokens.
        - Created new backend endpoints (`/api/auth/login`, `/api/auth/magic-link-callback`) to manage the flow.
    - **Critical Bug Fixes**:
        - **Build Failure**: Resolved an `Uncaught ReferenceError: require is not defined` build error by renaming frontend JavaScript files from `.js` to `.mjs` to explicitly signal their ES Module type to the Vercel build system.
        - **Routing & Caching Issues**: Fixed an incorrect redirect by changing the login route from `/login` to `/signin` to bypass a stale Vercel Edge Cache entry.
        - **Session Data Mismatch**: Corrected the magic link callback logic to set the correct `cloudbeds_user_id` in the user's session, which resolved an issue where the dashboard failed to load user properties.
- **Outcome**: The magic link authentication system was successfully implemented. Multiple critical bugs were resolved, restoring the application to a stable and functional state.


---


### **Date: July 10, 2025**
- **Objective**: Overhaul the application's authorization model, redesign the Admin Panel, and build an in-app API exploration tool.
- **Summary**: A foundational refactor of the authentication system was completed, moving from a dual-login system to a unified, database-driven role model. The Admin Panel was also rebuilt with a new UI and a powerful API explorer.
- **Key Changes**:
    - **Database-Driven Role System**:
        - **Problem**: A dual-login system (magic link for users, password for admin) was causing session corruption bugs.
        - **Resolution**: Removed the separate admin login and added an `is_admin` boolean column to the `users` table. The login flow was unified, with the user's admin status now stored in their session upon login. New role-specific API middleware (`requireUserApi`, `requireAdminApi`) was created to protect endpoints.
    - **Admin Panel Overhaul**:
        - The Admin Panel UI was completely redesigned to match the main dashboard's aesthetic.
        - Created a dynamic, in-app "Cloudbeds API Explorer" tool, allowing administrators to query API datasets and inspect their structure directly from the UI. This explorer was later enhanced to query real sample data from both the Insights and General APIs.
- **Outcome**: The session conflict bug was resolved. The new role-based system is more secure and scalable, and the Admin Panel was transformed into a professional and highly functional utility.


---


### **Date: July 11, 2025**
- **Objective**: Build a feature-rich Advanced Reporting page, including market comparisons, robust exporting, and a fully reactive UI.
- **Summary**: This was an extensive development session focused on the `reports.html` page. It covered the entire lifecycle of a PDF export feature (from creation to deletion) and concluded with a major, successful architectural refactor of the page's frontend to use Alpine.js.
- **Key Changes**:
    - **Reporting Features**:
        - Built UI for custom report generation with market comparisons and automatic "Delta" calculations (Your Hotel vs. Market).
        - Implemented flexible "Group by Metric" and "Group by Source" display modes for advanced analysis.
    - **PDF Export Lifecycle**:
        - An initial attempt at client-side PDF export using `jsPDF` failed due to CDN and library loading issues.
        - The feature was re-architected to use a server-side `puppeteer` solution, but this also suffered from critical, unresolvable file corruption and layout bugs.
        - **Decision**: After multiple failed attempts, the entire PDF export feature was removed from the application to reduce complexity and improve stability.
    - **Architectural Refactor (Alpine.js)**:
        - The Advanced Reporting page's frontend was refactored from an imperative, manual DOM manipulation model to a modern, declarative approach using Alpine.js.
        - All interactive controls were bound to the Alpine component's state, eliminating the need for manual event listeners and creating a fully reactive UI where any change instantly updates the report.
        - The process involved resolving a JavaScript module scope issue where Alpine.js could not access functions inside a module, which was fixed by explicitly exposing the handler function to the `window` object.
- **Outcome**: The Advanced Reporting page was transformed into a stable, powerful, and maintainable tool with a fully reactive interface. The problematic PDF export feature was strategically removed, and the successful Alpine.js refactor established the go-forward architectural pattern for the rest of the application's frontend.


---


### **Date: July 12, 2025**
- **Objective**: Modernize the main application dashboard by refactoring its frontend to align with the new reactive pattern.
- **Key Changes**:
    - Following the successful pattern from the reports page, the main dashboard's frontend (`public/app/index.html` and `dashboard.mjs`) was completely overhauled.
    - The previous implementation, which relied on imperative JavaScript and manual DOM manipulation, was replaced with a clean, declarative architecture powered by a single self-contained Alpine.js component (`x-data="dashboardPage()"`).
    - All dashboard logic was consolidated into the `dashboardPage()` component object, and the HTML was simplified to a clean template with Alpine directives (`x-text`, `x-show`, etc.) bound to the component's state.
- **Outcome**: The dashboard's frontend is now stable, maintainable, and architecturally consistent with the rest of the application, resolving a significant piece of technical debt.


---


### **Date: July 13, 2025**
- **Objective**: Implement a reusable shared header, connect the Advanced Reporting page to live data, and resolve a critical chart rendering bug on the main dashboard.
- **Summary**: This session focused on creating a a component-based architecture for the UI, followed by connecting the reports page to the backend. It concluded with a deep debugging session that resulted in migrating to a new charting library.
- **Key Changes**:
    - **Shared Header Component**:
        - A reusable header component was created and stored in `/public/app/_shared/` to ensure a consistent UI.
        - A JavaScript race condition that occurred while loading the component was resolved by ensuring the component's logic was imported and registered *before* its HTML was injected into the DOM.
    - **Live Data for Reporting**:
        - The Advanced Reporting page was successfully connected to the backend API, replacing its mock data generator with live data from the database.
        - A data-fetching race condition between the header and the report was resolved by implementing a custom event listener (`property-changed`), ensuring the report only fetches data after the header has loaded the user's properties.
    - **Dashboard Chart Migration (ECharts)**:
        - **Problem**: The existing chart library (`Chart.js`) suffered from an unresolvable race condition, causing frequent crashes and visual glitches.
        - **Resolution**: The application was migrated to the more robust Apache ECharts library. The tooltip formatting then failed due to a deep architectural conflict between ECharts and Alpine.js, which was resolved by completely decoupling the chart logic into a standalone `chartManager` object that is no longer controlled by Alpine.
- **Outcome**: The application now features a more consistent and maintainable UI with a shared header. The Advanced Reporting page is fully functional with live data. The dashboard chart is stable and visually polished after a successful migration to ECharts.


---


### **Date: July 14, 2025**
- **Objective**: Implement an end-to-end automated report scheduling system and standardize the UI by integrating the shared header into the main dashboard.
- **Summary**: A major feature, scheduled reports via email, was fully implemented from the database schema to the frontend UI. This was followed by a final refactor to align the main dashboard with the new shared component architecture.
- **Key Changes**:
    - **Report Scheduling Feature**:
        - A `scheduled_reports` table was added to the database to store report configurations.
        - New API endpoints (`POST`, `GET`, `DELETE /api/scheduled-reports`) were created to manage schedules.
        - An automated Vercel Cron Job (`/api/send-scheduled-reports.js`) was built to query for due reports, generate a CSV file with live data, and email it as an attachment using SendGrid.
        - **Decision**: An attempt to add server-side PDF generation for scheduled reports failed due to an unresolvable Vercel build/dependency issue with `puppeteer`. The feature was strategically removed to ensure the stability of the core scheduler.
    - **Dashboard UI Standardization**:
        - The main dashboard's static header was replaced with the dynamic, shared header component.
        - All duplicated header logic was removed from the dashboard's script.
        - The dashboard was refactored to be event-driven; it now listens for the `property-changed` event from the header to refresh its data, decoupling the components.
- **Outcome**: The report scheduling feature is production-ready and fully functional for CSV and Excel formats. The application's primary pages now share a single, consistent UI component, completing the UI standardization effort.


---


### **Date: July 15, 2025**
- **Objective**: Address significant technical debt by refactoring the monolithic `server.js` file into a modular architecture.
- **Key Changes**:
    - The entire backend was refactored to eliminate the risks of a single, monolithic `server.js` file.
    - Core API logic was separated into four distinct, feature-based Express Router files in `/api/routes/`: `auth.router.js`, `dashboard.router.js`, `reports.router.js`, and `admin.router.js`.
    - Shared utilities, including the database connection pool (`db.js`) and authentication middleware (`middleware.js`), were extracted into a `/api/utils/` directory.
    - The main `server.js` file was simplified to be a lean script that only initializes the server and mounts the new routers.
- **Outcome**: The backend refactoring was completed successfully. The new modular structure improves code organization, enhances maintainability, and makes the application significantly easier and safer to extend in the future.


Date: July 15, 2025 (Part 2)
* Objective: Implement a "Pilot Mode" to allow pre-certification onboarding of hotels using manual API credentials.
* Summary: A critical discovery revealed that the standard OAuth 2.0 flow is disabled for uncertified applications, blocking new hotel onboarding. A new, parallel authentication system was designed and implemented to bypass this limitation for a select group of pilot hotels. This involved a significant architectural pivot, several rounds of database refactoring, and a deep debugging session to resolve a complex foreign key constraint issue.
* Key Changes:
   * Architectural Pivot:
      * Initial Discovery: Realized that a standard hotel account cannot authorize an uncertified app, making the existing OAuth flow unusable for pilots. Discovered that Cloudbeds allows hotel admins to manually generate API credentials (Client ID & Client Secret) within their account.
      * Initial (Incorrect) Plan: An initial plan to store one set of credentials per user was abandoned after discovering that in multi-property accounts, each hotel has its own unique set of API credentials.
      * Final (Correct) Plan: The architecture was redesigned to be property-centric. The system now stores a unique set of override credentials for each property linked to a pilot user.
   * Database Schema Evolution:
      * Added auth_mode and needs_property_sync columns to the users table to identify pilot users and trigger a one-time property list sync.
      * Removed the NOT NULL constraint from token-related columns in the users table to accommodate pilot users who will not have OAuth tokens.
      * Added override_client_id and override_client_secret columns to the user_properties table to store credentials on a per-property basis.
      * Critical Debugging: Resolved a persistent foreign key constraint violation by removing the faulty constraint from the user_properties table, bringing the database rules in line with the application's established (but inconsistent) user identification logic.
   * Backend Implementation:
      * Created a new /api/utils/cloudbeds.js utility to centralize all Cloudbeds API interactions.
      * Built a new admin-only API endpoint (POST /api/set-credentials) to allow an administrator to securely provision properties for pilot users.
      * Overhauled the requireUserApi function in /api/utils/middleware.js. It now detects users with auth_mode = 'manual', fetches a temporary access token using their stored property-specific credentials, and caches it in the user's session.
   * Impact on OAuth Flow:
      * The standard OAuth 2.0 flow remains the primary, long-term authentication method and is completely unaffected by these changes. The new pilot mode logic runs on a separate, conditional path that is only triggered for users explicitly marked as 'manual'.
   * Future Migration Path:
      * The system is designed for a simple migration. Once the application is certified on the Cloudbeds Marketplace, pilot users will be instructed to log in once via the standard OAuth flow. This will automatically connect their account the standard way, and the manual override credentials can be cleared from the database.
* Outcome: The "Pilot Mode" feature was successfully implemented, providing a secure and robust method for onboarding hotels before official marketplace certification. The system can now handle both multi-property users with a single login and single-property users, all while preserving the integrity of the primary OAuth 2.0 architecture.
Date: July 15, 2025 (Part 3)
* Objective: Debug and resolve a series of critical post-implementation bugs to make the "Pilot Mode" feature fully functional, and build the final user interface for connecting pilot hotels.
* Summary: After the initial implementation of the pilot mode, a series of complex bugs emerged, primarily a persistent login loop for the new pilot user. This session involved a deep, systematic debugging process that uncovered issues with session management, email services, and server build configurations. The session concluded with a strategic pivot to build a more robust and permanent UI for the connection flow directly within the Admin Panel.
* Key Changes:
   * SendGrid Authentication Fix:
      * Problem: The magic link login system failed for all users with a 401 Unauthorized error.
      * Discovery: Realized that although the cron job for scheduled reports could send emails, the main authentication router had never been initialized with the SendGrid API key.
      * Resolution: Added sgMail.setApiKey(process.env.SENDGRID_API_KEY); to the top of /api/routes/auth.router.js, which immediately restored the magic link functionality.
   * Login Loop & Session Debugging:
      * Problem: The new pilot user (karol@rockenue.com) was stuck in an infinite loop, being redirected back to the sign-in page immediately after clicking their magic link.
      * Discovery: Through a "trail of breadcrumbs" debugging strategy using console.log statements in the Vercel logs, it was confirmed that the user's session was being created successfully but was being "lost" on the subsequent request to the dashboard.
      * Resolution: The root cause was identified as a fragile session cookie configuration. The explicit .market-pulse.io domain setting was removed from the cookie configuration in server.js and the /logout route, allowing the browser to handle the domain automatically and making the session "stick" correctly. A race condition was also fixed by moving the res.redirect() call inside the req.session.save() callback in the /magic-link-callback route.
   * Vercel Build Failure & Syntax Error:
      * Problem: The application began failing to build on Vercel, with logs indicating a SyntaxError: Unexpected token '}' in auth.router.js.
      * Resolution: The issue was traced to a copy-paste error that had corrupted the file. The entire contents of auth.router.js and admin.router.js were replaced with clean, verified versions, which resolved the build failure.
   * Final Architecture & UI (Admin Panel Integration):
      * Decision: The initial plan to create a one-off connect.html page was discarded in favor of a more professional and permanent solution, based on user feedback.
      * Implementation: The pilot hotel connection flow was integrated directly into the Admin Panel. A new "Pilot Hotel Connection Status" table was added to /public/admin/index.html. This table is populated by a new API endpoint (GET /api/pilot-properties) and provides a "Connect" button for each pending hotel.
      * Connection Flow: The "Connect" button links to a new /api/auth/connect-pilot-property route, which initiates the OAuth flow using the specific hotel's credentials. The main /api/auth/cloudbeds/callback route was enhanced to intelligently handle both this new pilot flow (by checking the state parameter) and the standard OAuth flow, storing tokens in the correct user_properties record and redirecting the admin back to the Admin Panel.
* Outcome: The application is now stable, and the "Pilot Mode" feature is functionally complete and ready for the final connection test. The Admin Panel provides a robust and intuitive interface for both provisioning pilot hotels and managing their connection status, creating a scalable solution for future onboarding.


Date: July 15, 2025 (Part 4)
* Objective: Finalize and debug the "Pilot Mode" connection flow to allow for the successful activation of manually provisioned hotels.
* Summary: This was a deep and iterative debugging session that began by trying to fix a failing connection process. An initial set of fixes led to the discovery, through Cloudbeds' documentation, that our fundamental approach to pilot authentication was incorrect. This prompted a major architectural pivot, replacing a fragile redirect-based flow with a robust, backend-only activation process. The new architecture was successfully implemented, and the pilot hotel was fully connected and registered in the database. However, this work surfaced a critical regression, leaving the user login process in a broken state.
* Key Changes:
   * API Key Discovery: The initial connection failure led to an investigation of the Cloudbeds documentation. It was discovered that for this "backdoor" access method, the generated API Key is not used to get a token; it is the token. It can be used directly in the Authorization: Bearer header for API calls.
   * Architectural Pivot:
      * The redirect-based connection flow for pilot users was completely abandoned in favor of a simpler, more reliable backend-only process.
      * The database schema for the user_properties table was updated with an ALTER TABLE command to add a new override_api_key column to store the new credential.
   * Backend Implementation:
      * The POST /provision-pilot-hotel endpoint in the Admin Panel was updated to accept and save the new API key.
      * The POST /activate-pilot-property endpoint was refactored. It no longer initiates a redirect; instead, it uses the stored API key to directly fetch hotel details from Cloudbeds and update the property's status to "connected" in a single transaction.
      * The core requireUserApi middleware was simplified. For users in manual mode, it now directly uses the stored API key for the requested property on all subsequent API calls, eliminating the need to fetch temporary tokens.
      * The redundant getManualAccessToken function was removed from api/utils/cloudbeds.js.
   * Login Flow Debugging:
      * A new bug emerged where a successfully connected pilot user was being incorrectly redirected to the /admin page instead of the dashboard.
      * An attempt was made to fix this by making the redirect logic in the /magic-link-callback more intelligent, checking if a user already had connected properties.
* Outcome: The primary objective was a success. The pilot hotel activation flow is now correctly architected and fully functional. A hotel can be provisioned and activated successfully from the Admin Panel, with its details correctly saved to the hotels table. However, the session concluded with a critical regression: the fix to the login redirect introduced an infinite loop, sending the user back to the magic link page after login. The application is currently in a non-working state for user logins. Resolving this login loop is the top priority for the next session.
Date: July 15, 2025 (Part 5)
* Objective: Resolve all post-implementation bugs for the "Pilot Mode" feature, moving it from a non-functional state to a fully operational one.
* Summary: This was an intensive debugging session that began by fixing a critical, site-wide login loop. Once access was restored, a series of cascading middleware bugs preventing the pilot user's dashboard from loading were systematically identified and resolved.
* Key Changes:
   * Login Loop Fix: A persistent login loop was traced to an incorrect session cookie configuration that caused the user's session to be lost between requests. The issue was resolved by adding
domain: ".market-pulse.io" to the cookie configuration in server.js, which ensures the session cookie is correctly handled by the browser across subdomains .
   * Dashboard Access Fix: The pilot user's dashboard initially failed to load because the requireUserApi middleware required an X-Property-ID header on all API calls. This created a chicken-and-egg problem where the initial call to get the list of properties (/api/my-properties) was blocked. The middleware was updated to create an
allowedPaths exception for non-property-specific routes, resolving the access issue.
   * Dashboard Data Fix: After fixing the access issue, subsequent API calls were still failing with a 400 error. This was traced to a mismatch where the middleware expected the propertyId in the request headers, but the frontend was sending it in the URL query string. The middleware was corrected to read the
propertyId from the query string, aligning the back-end expectation with the front-end implementation.
   * Outcome: The application is now fully stable. The critical login bug is resolved for all users. The "Pilot Mode" feature is now functionally complete, allowing pilot users to log in and view their hotel-specific data on the dashboard as intended.
Date: July 15, 2025 (Part 6)
   * Objective: Enable backend data synchronization for "Pilot Mode" users by running the initial data pull.
   * Summary: After fixing the dashboard UI, the backend sync scripts (initial-sync and daily-refresh) were found to be incompatible with the "Pilot Mode" authentication method. Both scripts were refactored to handle manual API keys. This work successfully resolved our internal bugs but then uncovered a hard 403 Forbidden error from the Cloudbeds API, shifting the problem from our codebase to an external permission issue.
   * Key Changes:
   * Backend Sync Refactor: Both initial-sync.js and daily-refresh.js were updated. The scripts, originally built only for OAuth users, now detect a user's
auth_mode. If the mode is 'manual', the scripts correctly use the property-specific override_api_key instead of attempting to use a non-existent refresh_token.
   * API Permission Discovery: After the refactor, running the initial sync failed with a 403 Forbidden error with the message "User does not have permission to VIEW report". This confirmed that the issue is not with our code's logic but with the permissions associated with the manually generated Cloudbeds API key.
      * Outcome: Our internal backend scripts are now complete and correctly handle both standard and pilot user authentication flows. However, the data sync for pilot users is currently blocked by the 403 Forbidden error from the Cloudbeds API. The immediate next step is to await a response from Cloudbeds support to resolve this final permission issue.
Date: July 15, 2025 (Part 7)
      * Objective: Resolve the final 403 Forbidden error to complete the data sync for pilot hotels, based on new research about enabling the app's "active session."
      * Summary: This session was dedicated to implementing the final piece of the puzzle suggested by our research: explicitly enabling the app's session for the pilot hotel. The team built out the entire feature, from the backend API call to the frontend UI in the Admin Panel. However, the attempt to enable the app failed with a new, more fundamental permission error from the Cloudbeds API. This confirmed that the issue is not with our workflow but with the inherent limitations of the manually generated API key.
      * Key Changes:
      * App State Enablement Feature:
      * A setCloudbedsAppState helper function was added to /api/utils/cloudbeds.js to make a POST request to the /api/v1.1/postAppState endpoint.
      * A new /api/enable-pilot-app route was created in /api/routes/admin.router.js to securely call this new function.
      * The Admin Panel UI (/public/admin/index.html and /public/admin/admin.mjs) was updated to dynamically show an "Enable App" button for pilot hotels with a "connected" status.
      * Final Diagnosis:
      * Executing the "Enable App" feature failed with a definitive error from Cloudbeds: You don't have access to property ID.
      * This proves that the manually generated API key lacks the necessary permissions to perform even basic administrative actions (like enabling its own app state) for the property it was created for.
      * Outcome: The "Pilot Mode" feature is now fully developed from our end, with all necessary logic in place to provision, activate, and enable a pilot hotel. However, the feature is currently blocked by a hard permission wall on the Cloudbeds API. The issue is now outside of our control, and the feature is shelved pending a response from Cloudbeds support, who are the only ones who can resolve this permission issue.